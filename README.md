# Gram Framework

Gram Framework -- проект, направленный на более строгое, модульное программирования с использованием некоторых ключевыйх идей MVC, контрактного программирования, django forms и Django Rest Framework.

Какие проблемы решает данный проект?
1. Проблема смешивания валидации и действий. Например, необходимо сохранить список объектов, переданных пользователем, в базу данных. Часть объектов успешно сохраняется, а затем, на очередном шаге итерации, оказывается, что один из объектов не валиден. Пользователю возвращается сообщение о том, что сохранение объектов невозможно, тогда как частично операция уже была проведена. На практике такие ситуации бывает довольно сложно выявить.
2. Проблема раскидывания декораторов по всему проекту. Иногда они декорируют представление в urls, иногда само представление, иногда (в случае CBV) метод dispatch, иногда -- метод post или get.
3. Проблема огромный представлений на тысячу строк, в которых намешано всё и сразу.
4. Проблема дублирования одной и той же логики в нескольких частях проекта. Например, обработка запросов с сайта и запросов к API.

Цели проекта:
1. Исключение логики валидации данных из основной логики.
2. Переиспользование основной логики. Например, построение сайта и REST API для общих задач.
3. Пост-валидация данных для гарантированного формата ответа, приходящего от представления.

Поток данных, попадая в Django-представление, использующее Gram Framework, проходит следующие этапы:
1. **Decorators**. Представление может быть обернуто в несколько декораторов. В Django для декорирования CBV приходится либо выносить декораторы в urls, что неявно и неинтуитивно размазывает логику представления по приложению, либо декорировать метод dispatch, но такая конструкция выглядит чертовски избыточно. Для избежания вот этого всего декораторы добавлены непосредственно в фреймворк.
2. **Validator**. Производит валидацию приходящих данных. Основная логика в принципе не может возвращать ошибки, только поднимать исключения, которые уже будут обрабатываться самим Django, вне Gram Framework. В качестве валидаторов используются немного пропатченные django-формы. Также валидатор очищает данные, которые уже попадают в контроллер:
	1. Приведение переданных параметров к нужному типу данных.
	2. Замена ID объекта модели на сам инстанс модели.
	3. Удаление лишних параметров, для которых не задана валидация
3. **ErrorSerializer**. Вызывается, если при валидации данных произошла ошибка.
4. **Controller**. Основная логика приложения. В качестве контроллера может выступать любой callable-объект. Контроллер либо успешно обрабатывает данные и возвращает ответ, либо поднимает исключение. В последнем случае дальнейшие шаги фреймворка уже игнорируются, а исключение обрабатывается на уровне Django. Намеренно поднимать исключение следует только если это гарантированно не нарушит 
5. **PostValidator**. Проверяет данные, возвращенные контроллером, на корректность, и приводит их к нужному виду. Позволяет гарантировать приложениям, обращающимся к представлению, определенный интерфейс ответа. По сути, те же валидаторы, применяемые к ответу контроллера.
6. **Serializer**. Сериализует данные, пришедшие из пост-валидатора, и возвращает их пользователю. Здесь данные могут запихиваться в django templates, json, xml, yaml или другие форматы ответа.

Обязательными являются только Controller и Serializer. Если отсутствует ErrorSerializer, используется Serializer. Если отсутствуют иные компоненты (Decorators, Validator, PostValidator), они просто пропускаются.

Многие перечисленные компоненты уже реализованы в Gram Framework или Django, а всё остальное необходимое Вы можете реализовать самостоятельно, используя описанные ниже интерфейсы и примеры.


## Интерфейсы

### Decorators

Список декораторов, оборачивающих представление. На вход оборачиваемой функции (строго говоря - одного из методов фреймворка) идут объект request и параметры из urls, а возвращает она уже сериализованный ответ представления.

### Validator и PostValidator

1. `__init__()` -- принимает следующие параметры:
	1. data, содержащий данные, пришедшие от пользователя или ответ от контроллера.
	2. request -- объект Request.
	3. Также могут прийти иные параметры, принимаемые django-формами. Передать их можно перегрузив у представления метод `get_validator_kwargs` или с помощью `functools.partial`.
2. `is_valid()` -- возвращает True, если валидация данных пройдена успешна, иначе - False.
3. `errors` -- словарь, устанавливаемый методом `is_valid()` в случае неуспешной валидации. Структура аналогичная: ключи -- названия параметров, значения -- список ошибок.
4. `cleaned_data` -- словарь данных, передаваемых в контроллер в случае успешной валидации.

### Controller

Любой callable-объект. Встроенные в фреймворк контроллеры являются callable-классами. Соответственно, перед передачей в фреймворк их необходимо инициализировать. При вызове в контроллер передаются следующие данные:
1. request -- объект Request.
2. data -- очищенные валидатором (если он был задан) данные, пришедшие от пользователя.
3. Именованные аргументы (kwargs), распарсенные urls. Да-да, позиционные не передаются, просто потому что их использование неявное, и от этого лучше отказаться, пока не поздно. В Django 2.0 их вообще нет, вроде как.

### Serializer и ErrorSerializer

Аналогично контроллерам, сериализаторы - любые callable-объекты. И точно так же встроенные сериализаторы требуют инициализации. В них передаются следующие данные:
1. request - объект Request
2. data - обработанный пост-валидатором ответ контроллера. Отсутствует, если при пост-валидации произошла ошибка.
3. validator - валидатор или пост-валидатор, который не был пройден. Отсутствует, если валидация и пост-валидация прошли успешно (либо отсутствовали).

## Встроенные объекты

### Validator и PostValidator

Базовые валидаторы:
* **IValidator** -- описывает интерфейс для валидатора. Используйте его в качестве родительского объекта, чтобы не забыть реализовать что-то нужное.
* **FormValidator** -- пропатченные django-формы. Принимают на вход объект request. Собственно, на этом различия заканчиваются.
* **ModelFormValidator** -- аналогичный объект, но только для модельных форм.
* **ListValidator** -- валидация элементов списка. Используйте `functools.partial`, чтобы через параметр `validator` задать нужный валидатор. Пример создания валидатора для списка чисел:
	```
    functools.partial(ListValidator, validator=IsBoolValidator)
    ```
* **DictValidator** -- объект, аналогичный `ListValidator`, но для валидации значений словаря.
* **DictMixedValidatorFactory** -- валидация значений словаря различными валидаторами. Инициализируется при объявлении и принимает следующие параметры:
    * `validators` - словарь валидаторов, где ключ совпадает с ключом валидируемых данных
    * `validate_all` - если отсутствует валидатор для какого-либо ключа, то...
        `True` - возвращает ошибку валидации
        `False` - Добавляет в результат данные без валидации
* **TypeValidator** - проверяет, что результат является объектом заданного типа. Тип данных задается с помощью аргумента `data_type`.

Дополнительные валидаторы на основе базовых:
* **ListFormValidator** -- Валидация элементов списка с помощью Django-форм
* **DictFormValidator** -- Валидация значений словаря с помощью Django-форм
* **ListModelFormValidator** -- Валидация элементов списка с помощью модельных форм Django
* **DictModelFormValidator** -- Валидация значений словаря с помощью модельных форм Django
* **IsBoolValidator** -- проверка того, что переданное значение является значением типа bool.
* **IsIntValidator** -- проверка того, что переданное значение является целым числом.
* **IsFloatValidator** -- проверка того, что переданное значение является числом с плавающей запятой.
* **IsStrValidator** -- проверка того, что переданное значение является строкой
* **IsIterValidator** -- проверка того, что переданное значение является итератором

### Controller

* **ListController**
* **InfoController**
* **AddController**
* **EditController**
* **DeleteController**

### Serializer и ErrorSerializer


### Rule, ViewBase



## Минимальный пример

TODO

```python
import gram_framework as gf

class UserAPIView(gf.ViewBase)
	rules = {
    	'get': gf.Rule(
        	decorators=None,
            validator=None,
            error_serializer=None,
            controller=None,
            post_validator=None,
            serializer=None,
        ),
    	'put': gf.Rule(
        	decorators=None,
            validator=None,
            error_serializer=None,
            controller=None,
            post_validator=None,
            serializer=None,
        ),
    	'delete': gf.Rule(
        	decorators=None,
            validator=None,
            error_serializer=None,
            controller=None,
            post_validator=None,
            serializer=None,
        ),
    }
```

## Ещё примеры