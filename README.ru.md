# DjBurger

DjBurger -- проект, направленный на более строгое, модульное программирование с использованием некоторых ключевых идей MVC, контрактного программирования, Django Forms и Django Rest Framework.

Какие проблемы решает данный проект?

1. Проблема смешивания валидации и действий. Например, необходимо сохранить список объектов, переданных пользователем, в базу данных. Часть объектов успешно сохраняется, а затем, на очередном шаге итерации, оказывается, что один из объектов не валиден. Пользователю возвращается сообщение о том, что сохранение объектов невозможно, тогда как частично операция уже была проведена. На практике такие ситуации бывает довольно сложно выявить.
2. Проблема раскидывания декораторов по всему проекту. Иногда они декорируют представление в urls, иногда само представление, иногда (в случае CBV) метод dispatch, иногда -- метод post или get.
3. Проблема огромный представлений на тысячу строк, в которых намешано всё и сразу.
4. Проблема дублирования одной и той же логики в нескольких частях проекта. Например, обработка запросов с сайта и запросов к API.

Цели проекта:

1. Исключение логики валидации данных из основной логики.
2. Переиспользование основной логики. Например, построение сайта и REST API для общих задач.
3. Пост-валидация данных для гарантированного формата ответа, приходящего от представления.

Поток данных, попадая в Django-представление, использующее DjBurger, проходит следующие этапы:

1. **Decorators** (d). Представление может быть обернуто в несколько декораторов. В Django для декорирования CBV приходится либо выносить декораторы в urls, что неявно и неинтуитивно размазывает логику представления по приложению, либо декорировать метод dispatch, но такая конструкция выглядит чертовски избыточно. Для избежания вот этого всего декораторы в DjBurger добавлены непосредственно в общую структуру.
2. **PreValidator** (prev). Производит валидацию приходящих данных. Основная логика в принципе не может возвращать ошибки, только поднимать исключения, которые уже будут обрабатываться самим Django, вне DjBurger. В качестве валидаторов используются немного пропатченные django-формы. Также валидатор очищает данные, которые уже попадают в контроллер:
	1. Приведение переданных параметров к нужному типу данных.
	2. Замена ID объекта модели на сам инстанс модели.
	3. Удаление лишних параметров, для которых не задана валидация
3. **PreRenderer** (prer). Вызывается, если при валидации данных произошла ошибка.
4. **Controller** (c). Основная логика приложения. В качестве контроллера может выступать любой callable-объект. Контроллер либо успешно обрабатывает данные и возвращает ответ, либо поднимает исключение. В последнем случае дальнейшие шаги фреймворка уже игнорируются, а исключение обрабатывается на уровне Django. Намеренно поднимать исключение следует только если это гарантированно не нарушит основную логику контроллера. Например, не приведет к частичному выполнению операций.
5. **PostValidator** (postv). Проверяет данные, возвращенные контроллером, на корректность, и приводит их к нужному виду. Позволяет гарантировать приложениям, обращающимся к представлению, определенный интерфейс ответа. По сути, те же валидаторы, применяемые к ответу контроллера. Полезны, в первую очередь, для отфильтровывания лишних сведений, которые не должны возвращаться пользователю, из объектов модели.
6. **PostRenderer** (postr). Вызывается, если при пост-валидации ответа контроллера произошла ошибка.
7. **Renderer** (r). Генерирует HttpResponse на основе данных, пришедшие из пост-валидатора. Здесь данные могут запихиваться в django templates, json, xml, yaml, xlsx или другие форматы.

Для реализации логики на каждом из этапов используются следующие типы компонентов:

1. **Decorator**. Совершенно любой декоратор :)
2. **Validator**. Используется в качестве PreValidator и PostValidator.
2. **Controller**. Любой callable объект
3. **Renderer**. Используется в качестве PreRenderer, PostRenderer и Renderer.

Многие компоненты уже реализованы в DjBurger, а всё остальное необходимое Вы можете реализовать самостоятельно, используя описанные ниже интерфейсы и примеры.


Правила описываются следующим образом:

```python
import djburger

class ExampleView(djburger.ViewBase):
    rules = {
        'get': djburger.rule(
            c=lambda request, data, **kwargs: 'Hello, World!',
            postv=djburger.v.c.IsStrValidator,
            postr=djburger.s.ExceptionSerializer,
            r=djburger.r.Template(template_name='index.html'),
        ),
    }
```

Некоторые правила:

1. `c` и `r` обязательные. Остальные компоненты могут быть пропущены.
2. Если пропущен `prer` или `postr`, то вместо него будет использоваться `r`.
3. Если пропущен `prev` или `postv`, то валидация на данном этапе не будет производиться.


## Installation

### STABLE

```bash
pip install djburger
```

### DEV

Через pip:

```bash
sudo pip install -e git+https://github.com/orsinium/djburger.git#egg=djburger
```

Как это добавить в `requirements.txt`? Ну как-то так:

```bash
-e git+https://github.com/orsinium/djburger.git#egg=djburger
```


## Интерфейсы


### Decorators

Список декораторов, оборачивающих представление. На вход оборачиваемой функции (строго говоря - одного из методов фреймворка) идут объект request и параметры из urls, а возвращает она уже сериализованный ответ представления.


### Validator

1. `__init__()` -- принимает следующие параметры:
	1. data, содержащий данные, пришедшие от пользователя или ответ от контроллера.
	2. request -- объект Request.
	3. Также могут прийти иные параметры, принимаемые django-формами. Передать их можно перегрузив у представления метод `get_validator_kwargs` или с помощью `functools.partial`.
2. `is_valid()` -- возвращает True, если валидация данных пройдена успешна, иначе - False.
3. `errors` -- словарь, устанавливаемый методом `is_valid()` в случае неуспешной валидации. Структура аналогичная: ключи -- названия параметров, значения -- список ошибок.
4. `cleaned_data` -- словарь данных, передаваемых в контроллер в случае успешной валидации.

Встроенные в DjBurger валидаторы разделены на 3 категории:

1. Base (b). Базовые классы для создания валидаторов
2. Constructors (c). Конструкторы для быстрого создания простых валидаторов. Например, для проверки типа данных ответа.
3. Wrappers (w). Специальные классы, которые позволяют оборачивать валидаторы из других фреймворков для их использования в DjBurger.

Из любого валидатора при вызовет метода `.is_valid()` можно поднять исключение `djburger.e.StatusCodeError`, проинициализированное HTTP-кодом. Это исключение будет поймано представлением, и будет вызван renderer для ошибки валидации, для ответа которого будет установлен данный HTTP-код.


### Controller

Любой callable-объект. Встроенные в фреймворк контроллеры являются callable-классами. Соответственно, перед передачей в фреймворк их необходимо инициализировать. При вызове в контроллер передаются следующие данные:

1. request -- объект Request.
2. data -- очищенные валидатором (если он был задан) данные, пришедшие от пользователя.
3. Именованные аргументы (kwargs), распарсенные urls. Да-да, позиционные не передаются, просто потому что их использование неявное, и от этого лучше отказаться, пока не поздно. В Django 2.0 их вообще нет, вроде как.


### Renderer

Аналогично контроллерам, renderer'ы - любые callable-объекты. И точно так же встроенные renderer'ы требуют инициализации. В них передаются следующие данные:

1. `request` - объект Request
2. `data` - обработанный пост-валидатором ответ контроллера. Отсутствует, если при пост-валидации произошла ошибка.
3. `validator` - валидатор или пост-валидатор, который не был пройден. Отсутствует, если валидация и пост-валидация прошли успешно (либо отсутствовали).
4. `status_code` - код состояния. Может отсутствовать.


## Сторонние библиотеки

На данный момент DjBurger поддерживает следующие сторонние модули:

* [Django REST Framework](django-rest-framework.org)
    * `djburger.v.b.RESTFramework`
    * `djburger.v.w.RESTFramework`
    * `djburger.r.RESTFramework`
* [Marshmallow](https://github.com/marshmallow-code/marshmallow)
    * `djburger.v.b.Marshmallow`
    * `djburger.v.w.Marshmallow`
* [PySchemes](https://github.com/shivylp/pyschemes)
    * `djburger.v.c.PySchemes`
    * `djburger.v.w.PySchemes`
* [PyYAML](https://github.com/yaml/pyyaml)
    * `djburger.r.YAML`
* [Tablib](https://github.com/kennethreitz/tablib)
    * `djburger.r.Tablib`

Если Вы используете в своём проекте какой-то иной способ валидации или сериализации данных -- просто напишите к нему собственную обертку.


## CodeStyle

DjBurger всего лишь разбивает представление на несколько базовых этапов и реализует для каждого из них основные концепции, применяемые чаще всего. Однако для крупного проекта необходимо строго определить правила работы с кодом, чтобы любой разработчик точно знал, где искать определенный функционал. В данном разделе приведены некоторые советы, от которых можно отталкиваться при написании собственных регламентов по работе с DjBurger.

Рекомендации:

1. Выносите этапы, описание которых занимает больше, чем несколько строк, из представления в отдельные модули.
2. Встроенные валидаторы позволяют построить валидацию любой сложности, однако их следует применять только для самых простых объектов. Для более сложных структур запроса или ответа используйте Django-формы или один из модулей, описанных в разделе "Сторонние библиотеки".
3. Если в проекте все представления строятся на основе DjBurger, лучше использовать базовые классы (`djburger.v.b`) вместо обёрток (`djburger.v.w`). Это позволит сократить количество ненужных слов и сразу обозначить, что данный объект или форма применяется для валидации данных. В ином случае имеет смысл использовать обёртки, чтобы гарантированно не потерять совместимость со сторонними библиотеками.
4. `djburger.c.ViewAsController` позволяет использовать в качестве контроллера представление. Старайтесь его не использовать, а писать чистые контроллеры. Его использование оправдано только в качестве промежуточного этапа при переходе от использовавшегося в Вашем проекте раньше подхода на основе CBV к DjBurger.
5. Если контроллер возвращает объект модели или queryset - лучше предварительно пропустить его через соответствующий валидатор (`djburger.v.c.ModelInstance` и `djburger.v.c.QuerySet` соответственно). Встроенные в DjBurger валидаторы поддерживают работу с моделями Django, однако в первую очередь они ориентированы на работу со словарями.
6. При пост-валидации старайтесь почаще использовать `djburger.v.c.Chain` для объединения нескольких валидаторов. Это позволяет дать исчерпывающий ответ на вопрос о том, что же возвращает контроллер.
7. Как правило, в рамках приложения (а иногда -- и всего проекта) используются одинаковые renderers, поэтому полезно прицепить к `djburger.rule` нужные `renderers` с помощью `functools.partial`.
8. Не создавайте для моделей методы, которые зависят от чего-либо, кроме самой модели. Это позволит избежать запутанных связей между приложениями и циклических импортов.
9. При создании API используйте HTTP коды ответов на полную катушку. Чтобы вернуть ошибку с указанным кодом состояния, используйте исключение `djburger.e.StatusCodeError`.

Рекомендуемые модули внутри приложения:

* constants -- все константы лучше выносить сюда, включая CHOICES из моделей.
* controllers
* decorators
* management -- management-команды django
* middleware -- промежуточные слои
* models -- модели
* postvalidators -- пост-валидаторы
* urls
* utils -- вспомогательные функции
* validators -- валидаторы входящих данных
* views -- представления


## Что дальше?

1. Примеры использования DjBurger приведены в демонстрационном Django-проекте (example) и тестах (tests.py).
2. Описание работы всех компонентов DjBurger приведено в docstring'ах. Не бойтесь заглядывать в исходники.


## TODO

* SubControllers
* REST Framework exceptions
* Example project
* More tests
* [schema](https://github.com/keleshev/schema)
* [schematics](https://github.com/schematics/schematics)

