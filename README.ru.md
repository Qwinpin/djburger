# DjBurger

DjBurger -- проект, направленный на более строгое, модульное программирование с использованием некоторых ключевых идей MVC, контрактного программирования, Django Forms и Django Rest Framework.

Какие проблемы решает данный проект?

1. Проблема смешивания валидации и действий. Например, необходимо сохранить список объектов, переданных пользователем, в базу данных. Часть объектов успешно сохраняется, а затем, на очередном шаге итерации, оказывается, что один из объектов не валиден. Пользователю возвращается сообщение о том, что сохранение объектов невозможно, тогда как частично операция уже была проведена. На практике такие ситуации бывает довольно сложно выявить.
2. Проблема раскидывания декораторов по всему проекту. Иногда они декорируют представление в urls, иногда само представление, иногда (в случае CBV) метод dispatch, иногда -- метод post или get.
3. Проблема огромный представлений на тысячу строк, в которых намешано всё и сразу.
4. Проблема дублирования одной и той же логики в нескольких частях проекта. Например, обработка запросов с сайта и запросов к API.

Цели проекта:

1. Исключение логики валидации данных из основной логики.
2. Переиспользование основной логики. Например, построение сайта и REST API для общих задач.
3. Пост-валидация данных для гарантированного формата ответа, приходящего от представления.

Поток данных, попадая в Django-представление, использующее DjBurger, проходит следующие этапы:

1. **Decorators** (d). Представление может быть обернуто в несколько декораторов. В Django для декорирования CBV приходится либо выносить декораторы в urls, что неявно и неинтуитивно размазывает логику представления по приложению, либо декорировать метод dispatch, но такая конструкция выглядит чертовски избыточно. Для избежания вот этого всего декораторы в DjBurger добавлены непосредственно в общую структуру.
2. **PreValidator** (prev). Производит валидацию приходящих данных. Основная логика в принципе не может возвращать ошибки, только поднимать исключения, которые уже будут обрабатываться самим Django, вне DjBurger. В качестве валидаторов используются немного пропатченные django-формы. Также валидатор очищает данные, которые уже попадают в контроллер:
	1. Приведение переданных параметров к нужному типу данных.
	2. Замена ID объекта модели на сам инстанс модели.
	3. Удаление лишних параметров, для которых не задана валидация
3. **PreRenderer** (prer). Вызывается, если при валидации данных произошла ошибка.
4. **Controller** (c). Основная логика приложения. В качестве контроллера может выступать любой callable-объект. Контроллер либо успешно обрабатывает данные и возвращает ответ, либо поднимает исключение. В последнем случае дальнейшие шаги фреймворка уже игнорируются, а исключение обрабатывается на уровне Django. Намеренно поднимать исключение следует только если это гарантированно не нарушит основную логику контроллера. Например, не приведет к частичному выполнению операций.
5. **PostValidator** (postv). Проверяет данные, возвращенные контроллером, на корректность, и приводит их к нужному виду. Позволяет гарантировать приложениям, обращающимся к представлению, определенный интерфейс ответа. По сути, те же валидаторы, применяемые к ответу контроллера. Полезны, в первую очередь, для отфильтровывания лишних сведений, которые не должны возвращаться пользователю, из объектов модели.
6. **PostRenderer** (postr). Вызывается, если при пост-валидации ответа контроллера произошла ошибка.
7. **Renderer**. Генерирует HttpResponse на основе данных, пришедшие из пост-валидатора. Здесь данные могут запихиваться в django templates, json, xml, yaml, xlsx или другие форматы.

Для реализации логики на каждом из этапов используются следующие типы компонентов:

1. Validator. Используется в качестве PreValidator и PostValidator.
2. Controller.
3. Renderer. Используется в качестве PreRenderer, PostRenderer и Renderer.

Многие компоненты уже реализованы в DjBurger, а всё остальное необходимое Вы можете реализовать самостоятельно, используя описанные ниже интерфейсы и примеры.


Правила описываются следующим образом:

```python
import djburger

class ExampleView(djburger.ViewBase):
    rules = {
        'get': djburger.rule(
            c=lambda request, data, **kwargs: 'Hello, World!',
            r=djburger.r.Template(template_name='index.html'),
            postv=djburger.v.c.IsStrValidator,
            postr=djburger.s.ExceptionSerializer,
            r=djburger.к.Template(template_name='index.html'),
        ),
    }
```

Некоторые правила:

1. `c` и `r` обязательные. Остальные компоненты могут быть пропущены.
2. Если пропущен `prer` или `postr`, то вместо него будет использоваться `r`.
3. Если пропущен `prev` или `postv`, то валидация на данном этапе не будет производиться.


## Installation

Через pip:

```bash
sudo pip install -e git+https://github.com/orsinium/djburger.git#egg=djburger
```

Как это добавить в `requirements.txt`? Ну как-то так:

```bash
-e git+https://github.com/orsinium/djburger.git#egg=djburger
```


## Интерфейсы

### Decorators

Список декораторов, оборачивающих представление. На вход оборачиваемой функции (строго говоря - одного из методов фреймворка) идут объект request и параметры из urls, а возвращает она уже сериализованный ответ представления.

### Validator

1. `__init__()` -- принимает следующие параметры:
	1. data, содержащий данные, пришедшие от пользователя или ответ от контроллера.
	2. request -- объект Request.
	3. Также могут прийти иные параметры, принимаемые django-формами. Передать их можно перегрузив у представления метод `get_validator_kwargs` или с помощью `functools.partial`.
2. `is_valid()` -- возвращает True, если валидация данных пройдена успешна, иначе - False.
3. `errors` -- словарь, устанавливаемый методом `is_valid()` в случае неуспешной валидации. Структура аналогичная: ключи -- названия параметров, значения -- список ошибок.
4. `cleaned_data` -- словарь данных, передаваемых в контроллер в случае успешной валидации.

### Controller

Любой callable-объект. Встроенные в фреймворк контроллеры являются callable-классами. Соответственно, перед передачей в фреймворк их необходимо инициализировать. При вызове в контроллер передаются следующие данные:

1. request -- объект Request.
2. data -- очищенные валидатором (если он был задан) данные, пришедшие от пользователя.
3. Именованные аргументы (kwargs), распарсенные urls. Да-да, позиционные не передаются, просто потому что их использование неявное, и от этого лучше отказаться, пока не поздно. В Django 2.0 их вообще нет, вроде как.

### Renderer

Аналогично контроллерам, renderer'ы - любые callable-объекты. И точно так же встроенные renderer'ы требуют инициализации. В них передаются следующие данные:

1. request - объект Request
2. data - обработанный пост-валидатором ответ контроллера. Отсутствует, если при пост-валидации произошла ошибка.
3. validator - валидатор или пост-валидатор, который не был пройден. Отсутствует, если валидация и пост-валидация прошли успешно (либо отсутствовали).


## Что дальше?

1. Примеры использования DjBurger приведены в демонстрационном Django-проекте (example) и тестах (tests.py).
2. Описание работы всех компонентов DjBurger приведено в docstring'ах. Не бойтесь заглядывать в исходники.

